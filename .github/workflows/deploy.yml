name: Build and Deploy Backend and Frontend Conditionally
# name: The workflow name shown in GitHub Actions UI.
# ‚úÖ What This Whole Job Does
# It checks:
# "Did any file in backend/** or frontend/** change?"
# If yes ‚Üí sets needs.detect-changes.outputs.backend or ...frontend to 'true'

on:
  push:
    branches:
      - production

# This section tells GitHub:
# "Only activate this machine when someone pushes code to the production branch."
# on: Specifies the event that triggers the workflow.
# Here: only runs when you git push to the production branch.
# This workflow runs only when you push to the production branch.

jobs:
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}

# Once triggered, the first job checks what changed in this push.
# It downloads the full diff of this commit vs the last one and runs the paths-filter logic

# jobs:
# This is the start of the entire set of jobs in the GitHub Actions workflow.
# Think of jobs as the parent block where you define individual pipelines that can run IN PARALLEL OR IN SEQUENCE.
  # detect-changes:
  # This is the name of one job, called detect-changes.
  # This job's only purpose is to figure out what part of the repo has changed in the current commit.
  # Later jobs like deploy-backend or deploy-frontend will "need" this job to run first and provide outputs.
    # name: Detect Changes
    # This is the human-readable name that will appear in the GitHub Actions UI.
    # runs-on: ubuntu-latest
    # This tells GitHub to spin up a fresh Ubuntu Linux virtual machine (runner) to perform this job.
    # It's where your scripts/actions will run.
    # outputs:
    # This section declares what this job will output so other jobs can use it.
    # In this case, you're declaring two outputs:
    # backend
    # frontend
    # These outputs come from a step that runs below, called filter.
      # backend: ${{ steps.filter.outputs.backend }}
      # This means:
      # "We're defining a job-level output named backend, and assigning it the value produced by the step with 
      # id: filter. Specifically, we're taking the backend output generated by that step ‚Äî which tells us whether
      # any backend-related files changed ‚Äî and exposing it at the job level so that other jobs in the workflow 
      # can access and react to it using needs.detect-changes.outputs.backend."
      # It references:
      # The step ID: filter (defined below in the steps section)
      # The output name from that step: backend
      # frontend: ${{ steps.filter.outputs.frontend }}
      # Same as above, but for the frontend.

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # üîß FIX: Fetch full git history instead of shallow clone
          # This is crucial for dorny/paths-filter to properly detect changes.
          # Without full history, it can't compare against previous commits properly.

    # steps:
    # This begins the list of actions or commands you want to run in this detect-changes job.
      # - name: Checkout code
      # A human-readable label. This will show as a step in the GitHub Actions UI.
      # It's good documentation and makes the UI readable.
      # uses: actions/checkout@v3
      # This tells GitHub to use the official GitHub Action called checkout.
      # It downloads your repository into the runner, so that future steps can access the actual code.
      # Without this, your next step (dorny/paths-filter) wouldn't be able to read the files.

      - name: Detect backend/frontend changes
        id: filter
        uses: dorny/paths-filter@v3
        with:
          base: HEAD~1  # üîß FIX: Explicitly compare against the previous commit
          # This ensures we're comparing the current commit against exactly one commit back,
          # rather than relying on the action's automatic detection which might be inconsistent.
          filters: |
            backend:
              - 'backend/**'
              - '.github/ecs-task-definitions/backend-td.json'
            frontend:
              - 'frontend/**'
              - '.github/ecs-task-definitions/frontend-td.json'
            
          # It looks at only file paths, and sets flags:
          # "backend": true if backend-related files changed
          # "frontend": true if frontend-related files changed
          # This is the decision logic: it tells the machine what needs to be done based on the observed change.

      # - name: Detect backend/frontend changes
      # This is the label for the step that uses the paths filter tool.
      # It performs pattern matching on changed files.
      # id: filter
      # This gives this step an ID (filter) so you can reference its outputs (as we did earlier in the outputs section of the jobs section).
      # uses: dorny/paths-filter@v3
      # This uses a third-party GitHub Action created by dorny.
      # It's a special tool to detect which files changed in a commit, based on path patterns.
      # It outputs true/false booleans for each section (frontend, backend) based on whether files in those paths changed.
      # with:
      # This block passes input values to the dorny/paths-filter action.
        # filters: |
        # The filters: key tells the action how to group your code.
        # The pipe (|) means a multi-line block is coming in YAML.
        # backend:
        # This defines the backend group.
        # If any file inside backend/ or the backend task definition file changes, the backend output will be true
        # frontend:
        # Same for the frontend group.

      - name: Debug filter outputs
        run: |
          echo "Backend changed: ${{ steps.filter.outputs.backend }}"
          echo "Frontend changed: ${{ steps.filter.outputs.frontend }}"
          echo "Changed files:"
          echo "${{ steps.filter.outputs.changes }}"
        # üêõ DEBUG: This step helps troubleshoot the path filtering
        # It will print to the GitHub Actions log exactly what the filter detected.
        # This way you can see if both outputs are showing 'true' when only one should be.
        # Remove this step once the issue is resolved.

  deploy-backend:
    name: Deploy Backend
    needs: detect-changes
    if: needs.detect-changes.outputs.backend == 'true'
    runs-on: ubuntu-latest

  # deploy-backend: ‚Äî Job identifier. Internally used by needs, outputs, etc.
  # name: ‚Äî Human-readable label in the Actions UI ("Deploy Backend").
  # needs: detect-changes
  # This job depends on the detect-changes job to run first.
  # It waits for detect-changes to finish and read its output.
  # if: needs.detect-changes.outputs.backend == 'true'
  # Only runs if backend files changed.
  # This is key: prevents the backend from rebuilding if no relevant files changed.
  # runs-on: ubuntu-latest
  # Runs this job inside a clean Linux VM provided by GitHub.

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
    # Checks out your code from the GitHub repo so it can be used inside the runner.

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      # Authenticates the runner with AWS.
      # You need this to talk to ECR (for pushing images) and ECS (for deploying tasks).

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_BACKEND_URI }}

      # Logs in to your Amazon ECR (Elastic Container Registry).
      # Required before docker push will work ‚Äî it's like authenticating with DockerHub but for AWS.

      - name: Build Backend Image
        run: |
          docker build -t backend-image ./backend
          docker tag backend-image ${{ secrets.ECR_BACKEND_URI }}:latest
          docker push ${{ secrets.ECR_BACKEND_URI }}:latest

      # Builds your backend Docker image from the ./backend folder.
      # Tags it with the ECR URI.
      # Pushes it to your backend ECR repo.

      - name: Render updated backend task definition
        id: render-backend
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: .github/ecs-task-definitions/backend-td.json
          container-name: dicom-server-backend
          image: ${{ secrets.ECR_BACKEND_URI }}

      # Reads your ECS task definition JSON for the backend.
      # Substitutes the image field with the new image you just built.
      # Outputs a new JSON file (rendered) for deployment.

      - name: Deploy backend to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.render-backend.outputs.task-definition }}
          service: ${{ secrets.ECS_BACKEND_SERVICE }}
          cluster: ${{ secrets.ECS_CLUSTER_NAME }}
          wait-for-service-stability: true

      # Registers the new task definition in ECS.
      # Updates your backend ECS service to use the new image.
      # Waits until the ECS service is stable (i.e., health checks pass, task is running).

  deploy-frontend:
    name: Deploy Frontend
    # Job for your React/Vite frontend.
    needs: detect-changes
    if: needs.detect-changes.outputs.frontend == 'true'
    runs-on: ubuntu-latest
    # Waits for detect-changes.
    # Runs only if the frontend files changed.

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      # Same as backend: check out your source code.

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
        # AWS login for pushing to ECR and deploying to ECS.

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_FRONTEND_URI }}

      # Login to frontend ECR registry.

      - name: Build Frontend Image
        run: |
          docker build \
            --build-arg VITE_API_URL=${{ secrets.VITE_API_URL }} \
            --build-arg VITE_COGNITO_USER_POOL_ID=${{ secrets.VITE_COGNITO_USER_POOL_ID }} \
            --build-arg VITE_COGNITO_CLIENT_ID=${{ secrets.VITE_COGNITO_CLIENT_ID }} \
            --build-arg VITE_AWS_REGION=${{ secrets.VITE_AWS_REGION }} \
            --build-arg VITE_COGNITO_DOMAIN=${{ secrets.VITE_COGNITO_DOMAIN }} \
            --build-arg VITE_COGNITO_REDIRECT_URI=${{ secrets.VITE_COGNITO_REDIRECT_URI }} \
            --build-arg VITE_COGNITO_RESPONSE_TYPE=${{ secrets.VITE_COGNITO_RESPONSE_TYPE }} \
            --build-arg VITE_OHIF_URL=${{ secrets.VITE_OHIF_URL }} \
            --build-arg VITE_GUEST_USERNAME=${{ secrets.VITE_GUEST_USERNAME }} \
            --build-arg VITE_GUEST_PASSWORD=${{ secrets.VITE_GUEST_PASSWORD }} \
            --build-arg VITE_COGNITO_AUTHORITY=${{ secrets.VITE_COGNITO_AUTHORITY }} \
            -t frontend-image ./frontend
          docker tag frontend-image ${{ secrets.ECR_FRONTEND_URI }}:latest
          docker push ${{ secrets.ECR_FRONTEND_URI }}:latest
      # Builds your frontend with all required environment variables using --build-arg.
      # Tags and pushes it to your frontend ECR repo.

      - name: Render updated frontend task definition
        id: render-frontend
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: .github/ecs-task-definitions/frontend-td.json
          container-name: dicom-server-frontend
          image: ${{ secrets.ECR_FRONTEND_URI }}
      # Same process as backend:
      # Replaces image in the task definition.
      # Prepares the new task definition file for ECS.

      - name: Deploy frontend to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.render-frontend.outputs.task-definition }}
          service: ${{ secrets.ECS_FRONTEND_SERVICE }}
          cluster: ${{ secrets.ECS_CLUSTER_NAME }}
          wait-for-service-stability: true
      # Registers and deploys the updated frontend image to ECS.
      # Waits until the ECS service is stable.


# name: Build and Push Docker Images to ECR
# # name: The workflow name shown in GitHub Actions UI.

# on:
#   push:
#     branches:
#       - production

# # on: Specifies the event that triggers the workflow.
# # Here: only runs when you git push to the production branch.
# # This workflow runs only when you push to the production branch.

# jobs:
#   build-and-push:
#     name: Build & Push Backend and Frontend
#     runs-on: ubuntu-latest

# # jobs: Defines what to do.
# # build-and-push: The name of this job (you can name it anything).
# # runs-on: The VM/environment to run on. ubuntu-latest gives you a Linux machine.

#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       # steps: List of actions to perform in the job.
#       # - name: Human-readable label.
#       # uses: Means you're calling a reusable GitHub Action.
#       # In this case, actions/checkout@v3 checks out your code.

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v2
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ secrets.AWS_REGION }}

#       # üîê Authenticates with AWS using GitHub Secrets
#       # Lets you run AWS CLI commands
#       # Required to log in to ECR and push images
#       # with: Used to pass inputs to the action
#       # ${{ secrets.X }}: Fetches values from GitHub Secrets

#       - name: Log in to Amazon ECR
#         run: |
#           aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_BACKEND_URI }}

#       # üîë Logs into ECR
#       # ECR requires Docker authentication
#       # This command gets a token and pipes it into docker login
#       # : Runs a shell command in the VM.
#       # | is YAML syntax for a multi-line block.

#       - name: Build Backend Image
#         run: |
#           docker build -t backend-image ./backend
#           docker tag backend-image ${{ secrets.ECR_BACKEND_URI }}:latest
#           docker push ${{ secrets.ECR_BACKEND_URI }}:latest

#       # üê≥ Builds, tags, and pushes your backend container

#       - name: Build Frontend Image
#         run: |
#           docker build \
#             --build-arg VITE_API_URL=${{ secrets.VITE_API_URL }} \
#             --build-arg VITE_COGNITO_USER_POOL_ID=${{ secrets.VITE_COGNITO_USER_POOL_ID }} \
#             --build-arg VITE_COGNITO_CLIENT_ID=${{ secrets.VITE_COGNITO_CLIENT_ID }} \
#             --build-arg VITE_AWS_REGION=${{ secrets.VITE_AWS_REGION }} \
#             --build-arg VITE_COGNITO_DOMAIN=${{ secrets.VITE_COGNITO_DOMAIN }} \
#             --build-arg VITE_COGNITO_REDIRECT_URI=${{ secrets.VITE_COGNITO_REDIRECT_URI }} \
#             --build-arg VITE_COGNITO_RESPONSE_TYPE=${{ secrets.VITE_COGNITO_RESPONSE_TYPE }} \
#             --build-arg VITE_OHIF_URL=${{ secrets.VITE_OHIF_URL }} \
#             --build-arg VITE_GUEST_USERNAME=${{ secrets.VITE_GUEST_USERNAME }} \
#             --build-arg VITE_GUEST_PASSWORD=${{ secrets.VITE_GUEST_PASSWORD }} \
#             --build-arg VITE_COGNITO_AUTHORITY=${{ secrets.VITE_COGNITO_AUTHORITY }} \
#             -t frontend-image ./frontend
#           docker tag frontend-image ${{ secrets.ECR_FRONTEND_URI }}:latest
#           docker push ${{ secrets.ECR_FRONTEND_URI }}:latest

#       # üñ•Ô∏è Same as above ‚Äî but for your frontend React app

#       - name: Render updated frontend task definition
#         id: render-frontend
#         uses: aws-actions/amazon-ecs-render-task-definition@v1
#         with:
#           task-definition: .github/ecs-task-definitions/frontend-td.json
#           container-name: dicom-server-frontend
#           image: ${{ secrets.ECR_FRONTEND_URI }}

#       # What it does:
#       # Reads your frontend-td.json
#       # Finds the container named dicom-server-frontend
#       # Replaces "image": "PLACEHOLDER" with your actual image URI
#       # Outputs a new .task-definition.json (in runner workspace)

#       - name: Deploy frontend to ECS
#         uses: aws-actions/amazon-ecs-deploy-task-definition@v1
#         with:
#           task-definition: ${{ steps.render-frontend.outputs.task-definition }}
#           service: ${{ secrets.ECS_FRONTEND_SERVICE }}
#           cluster: ${{ secrets.ECS_CLUSTER_NAME }}
#           wait-for-service-stability: true

#       # What it does:
#       # Registers the rendered task definition as a new revision (e.g., v2)
#       # Updates the ECS service to use this new revision
#       # ECS performs a rolling update:
#       # Starts new task with new image
#       # Waits for health check pass
#       # Stops old task

#       - name: Render updated backend task definition
#         id: render-backend
#         uses: aws-actions/amazon-ecs-render-task-definition@v1
#         with:
#           task-definition: .github/ecs-task-definitions/backend-td.json
#           container-name: dicom-server-backend
#           image: ${{ secrets.ECR_BACKEND_URI }}

#       # Backend: Same exact process as for the frontend-td.json above
#       # Just with:
#       # ecs-task-defs/backend.json
#       # dicom-server-backend
#       # ECR_BACKEND_URI
#       # Service name for backend

#       - name: Deploy backend to ECS
#         uses: aws-actions/amazon-ecs-deploy-task-definition@v1
#         with:
#           task-definition: ${{ steps.render-backend.outputs.task-definition }}
#           service: ${{ secrets.ECS_BACKEND_SERVICE }}
#           cluster: ${{ secrets.ECS_CLUSTER_NAME }}
#           wait-for-service-stability: true